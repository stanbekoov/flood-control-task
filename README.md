Изаначальным вариантом было хранение данных в PostgreSQL, но я решил от него отказаться из-за скорости выполнения,
Redis показывает куда лучшие результаты.

Затем появился вопрос, как хранить данные в БД. Была идея для каждого UserID хранить Hash,
но реализация получалось слишком уж громздкой, нечитабельной и по времени, даже если бы и опережала список, то несильUно.
Суть идеи была в том, что бы обращаться в соответствующем хэше к ключу time.Now().Unix() - K. Каждый ключ хранил в себе общее кол-во запросов к этому моменту.
Если бы данного ключа в хэше не было, то производился бы поиск ближайшего значения сверху. Как только оно найдено, мы просто вычитаем значение ключа из нынешнего количества запросов, что приводит к ассимптотике О(К).

Но было решено хранить списки для каждого UserID. i-й элемент списка хранит всего время i-го запроса.
При вызове чек мы добавляем в конец списка нынешнее время, а затем проходим по списку справа налево. Как только мы нашли первый элемент меньший 
time.Now().Unix() - K, мы сохраняем следующий индекс в переменную end - это последний элемент списка (с конца) >= time.Now().Unix() - K. Если же такого элемента найдено не было, мы оставляем значение end равным индексу последнего элемента списка. Затем, мы просто выполняем проверку, больше ли количество элементов в интервале [end, len(vals)) чем N. Это решение приводит к той же ассимптотике О(К), но при этом гороздо более читабельно и прозе для понимания# vk-intern-task
